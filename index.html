<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Canvas Stream - Presenter</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: sans-serif;
        background: #000;
      }
      video {
        position: absolute;
        width: 1px;
        height: 1px;
        opacity: 0;
        pointer-events: none;
      }
      canvas {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 0;
      }
      /* CONTROLS (Top Left) */
      .controls {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 2;
        background: rgba(15, 15, 15, 0.75);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        padding: 14px 18px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .controls .btn-row {
        display: flex;
        gap: 6px;
      }
      .controls button {
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
        border: 1px solid rgba(255, 255, 255, 0.15);
        padding: 8px 14px;
        border-radius: 8px;
        font-size: 13px;
        cursor: pointer;
        transition: all 0.2s;
      }
      .controls button:hover {
        background: rgba(255, 255, 255, 0.2);
      }
      /* Active States */
      .controls button.active-red {
        background: rgba(220, 38, 38, 0.8);
        border-color: rgba(220, 38, 38, 0.9);
      }
      .controls button.active-green {
        background: rgba(34, 160, 70, 0.8);
        border-color: rgba(34, 160, 70, 0.9);
      }
      .controls button.active-blue {
        background: #3b82f6;
        border-color: #60a5fa;
      }
      .controls a {
        display: inline-block;
        color: #8ab4f8;
        font-size: 13px;
        text-decoration: none;
        margin-top: 4px;
      }

      /* WISHLIST RECAP (Bottom Left) */
      .wishlist-recap {
        position: absolute;
        bottom: 20px;
        left: 20px;
        z-index: 2;
        width: 260px;
        max-height: 300px;
        background: rgba(15, 15, 15, 0.85);
        backdrop-filter: blur(12px);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 12px;
        padding: 14px;
        overflow-y: auto;
        color: #fff;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .wishlist-recap h3 {
        margin: 0;
        font-size: 14px;
        font-weight: 600;
        color: rgba(255, 255, 255, 0.9);
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        padding-bottom: 8px;
      }
      .wishlist-log {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .log-item {
        font-size: 12px;
        padding: 6px 8px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 6px;
        border-left: 3px solid #22a046;
      }
      .log-item span {
        display: block;
        color: rgba(255, 255, 255, 0.5);
        font-size: 10px;
        margin-top: 2px;
      }

      /* MANUAL PRODUCT SELECTOR (Bottom Center) - Hidden by default */
      .product-selector {
        position: absolute;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 2;
        background: rgba(0, 0, 0, 0.85);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 12px;
        padding: 12px;
        display: none; /* Hidden unless in Webcam Mode AND Publishing */
        gap: 10px;
        max-width: 90vw;
        flex-wrap: wrap;
        justify-content: center;
      }
      .product-selector.visible {
        display: flex;
      }
      .prod-btn {
        background: #333;
        border: 1px solid #555;
        color: white;
        padding: 6px 12px 6px 6px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 13px;
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 10px;
        transition:
          background 0.2s,
          transform 0.1s;
      }
      .prod-btn:hover {
        background: #444;
        transform: translateY(-2px);
      }
      .prod-btn.active {
        background: #22a046;
        border-color: #4ade80;
        box-shadow: 0 4px 12px rgba(34, 160, 70, 0.4);
      }
      .prod-btn img {
        width: 40px;
        height: 28px;
        object-fit: cover;
        border-radius: 4px;
        display: block;
      }
    </style>
  </head>
  <body>
    <video id="videoBg" src="./background.mp4" muted loop playsinline></video>
    <video id="webcam" autoplay muted playsinline></video>
    <canvas id="canvas"></canvas>

    <div class="controls">
      <div class="btn-row">
        <button id="modeToggle">Switch to Webcam Mode</button>
      </div>
      <div class="btn-row" id="videoControls">
        <button id="bgToggle" class="active-green">Play Background</button>
      </div>
      <div class="btn-row">
        <button id="publishToggle">Start Publish</button>
      </div>
      <a href="./player.html" target="_blank">Open Player</a>
    </div>

    <div class="product-selector" id="productSelector"></div>

    <div class="wishlist-recap">
      <h3>Live Wishlist Activity</h3>
      <div class="wishlist-log" id="wishlistLog">
        <div
          style="font-size: 12px; color: #666; font-style: italic"
          id="emptyMsg"
        >
          No items added yet...
        </div>
      </div>
    </div>

    <script type="module">
      import { WebRTCAdaptor } from "https://cdn.skypack.dev/@antmedia/webrtc_adaptor@SNAPSHOT";

      const videoBg = document.getElementById("videoBg");
      const webcam = document.getElementById("webcam");
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");

      const publishToggle = document.getElementById("publishToggle");
      const bgToggle = document.getElementById("bgToggle");
      const modeToggle = document.getElementById("modeToggle");
      const videoControls = document.getElementById("videoControls");
      const productSelector = document.getElementById("productSelector");

      const wishlistLog = document.getElementById("wishlistLog");
      const emptyMsg = document.getElementById("emptyMsg");

      var streamId = "streamCanvas";
      var webRTCAdaptor;
      var isPublishing = false;
      var isBgPlaying = false;
      var isWebcamMode = false;
      var syncInterval = null;
      var currentManualIndex = 0;

      const products = [
        { name: "Aviator Classic", brand: "Ray-Ban" },
        { name: "Wayfarer Original", brand: "Ray-Ban" },
        { name: "Clubmaster Metal", brand: "Ray-Ban" },
        { name: "Round Double Bridge", brand: "Ray-Ban" },
        { name: "Hexagonal Flat", brand: "Ray-Ban" },
      ];

      const carouselSources = [
        "https://images.unsplash.com/photo-1511499767150-a48a237f0083?w=200&h=120&fit=crop",
        "https://images.unsplash.com/photo-1572635196237-14b3f281503f?w=200&h=120&fit=crop",
        "https://images.unsplash.com/photo-1577803645773-f96470509666?w=200&h=120&fit=crop",
        "https://images.unsplash.com/photo-1509695507497-903c140c43b0?w=200&h=120&fit=crop",
        "https://images.unsplash.com/photo-1574258495973-f010dfbb5371?w=200&h=120&fit=crop",
      ];

      // --- SETUP PRODUCT BUTTONS ---
      products.forEach((p, idx) => {
        const btn = document.createElement("button");
        btn.className = "prod-btn";

        const img = document.createElement("img");
        img.src = carouselSources[idx];
        img.alt = p.name;

        const span = document.createElement("span");
        span.textContent = p.name;

        btn.appendChild(img);
        btn.appendChild(span);

        btn.onclick = () => setManualProduct(idx);
        productSelector.appendChild(btn);
      });

      function setManualProduct(index) {
        currentManualIndex = index;
        // Update visual active state
        const buttons = productSelector.querySelectorAll(".prod-btn");
        buttons.forEach((b, i) => {
          if (i === index) b.classList.add("active");
          else b.classList.remove("active");
        });
        // Send Data
        sendSyncData("force_product", index);
      }

      function resizeCanvas() {
        const targetW = videoBg.videoWidth || window.innerWidth;
        const targetH = videoBg.videoHeight || window.innerHeight;
        if (targetW && targetH) {
          canvas.width = targetW;
          canvas.height = targetH;
        }

        var ratio = canvas.width / canvas.height;
        var winW = window.innerWidth;
        var winH = window.innerHeight;
        var winRatio = winW / winH;
        if (winRatio > ratio) {
          canvas.style.height = winH + "px";
          canvas.style.width = Math.round(winH * ratio) + "px";
        } else {
          canvas.style.width = winW + "px";
          canvas.style.height = Math.round(winW / ratio) + "px";
        }
      }
      window.addEventListener("resize", resizeCanvas);

      navigator.mediaDevices
        .getUserMedia({ video: { width: 1280, height: 720 } })
        .then((stream) => {
          webcam.srcObject = stream;
        })
        .catch((err) => console.error(err));

      function drawWebcamCover() {
        if (webcam.readyState < 2) return;

        const cw = canvas.width;
        const ch = canvas.height;
        const vw = webcam.videoWidth;
        const vh = webcam.videoHeight;

        let scale = Math.max(cw / vw, ch / vh);
        let x = cw / 2 - (vw / 2) * scale;
        let y = ch / 2 - (vh / 2) * scale;

        ctx.drawImage(webcam, x, y, vw * scale, vh * scale);
      }

      function draw() {
        ctx.fillStyle = "#000000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        if (isWebcamMode) {
          drawWebcamCover();
        } else {
          if (videoBg.readyState >= 2) {
            ctx.drawImage(videoBg, 0, 0, canvas.width, canvas.height);
          }
          if (webcam.readyState >= 2) {
            ctx.save();
            ctx.shadowColor = "rgba(0,0,0,0.5)";
            ctx.shadowBlur = 10;
            // Maintain webcam aspect ratio
            const aspect = webcam.videoWidth / webcam.videoHeight;
            const camWidth = 400 * aspect;
            const camHeight = 400;
            ctx.drawImage(
              webcam,
              canvas.width - camWidth - 10,
              10,
              camWidth,
              camHeight,
            );
            ctx.restore();
          }
        }

        requestAnimationFrame(draw);
      }

      videoBg.addEventListener("loadedmetadata", () => {
        resizeCanvas();
        if (!webRTCAdaptor) initWebRTC();
      });

      // --- UI UPDATE FUNCTION (Centralized Logic) ---
      function updateUI() {
        // Logic for Mode Button and Video Controls
        if (isWebcamMode) {
          modeToggle.textContent = "Switch to Video Mode";
          modeToggle.classList.add("active-blue");
          videoControls.style.display = "none";
        } else {
          modeToggle.textContent = "Switch to Webcam Mode";
          modeToggle.classList.remove("active-blue");
          videoControls.style.display = "flex";
        }

        // Logic for Product Selector Visibility
        // Show ONLY if Webcam Mode AND Publishing are true
        if (isWebcamMode && isPublishing) {
          productSelector.classList.add("visible");
        } else {
          productSelector.classList.remove("visible");
        }
      }

      function addLogItem(productIndex) {
        if (emptyMsg) emptyMsg.style.display = "none";
        const product = products[productIndex];
        if (!product) return;
        const div = document.createElement("div");
        div.className = "log-item";
        div.setAttribute("data-index", productIndex);
        const now = new Date();
        const timeString =
          now.getHours() + ":" + String(now.getMinutes()).padStart(2, "0");
        div.innerHTML = `<strong>${product.name}</strong> added<span>${timeString}</span>`;
        wishlistLog.prepend(div);
      }
      function removeLogItem(productIndex) {
        const items = wishlistLog.querySelectorAll(
          `.log-item[data-index="${productIndex}"]`,
        );
        if (items.length > 0) items[0].remove();
        if (wishlistLog.querySelectorAll(".log-item").length === 0 && emptyMsg)
          emptyMsg.style.display = "block";
      }

      function initWebRTC() {
        var localCanvasStream = canvas.captureStream(25);
        webRTCAdaptor = new WebRTCAdaptor({
          websocket_url: "wss://test.antmedia.io:5443/WebRTCAppEE/websocket",
          localStream: localCanvasStream,
          callback: (info, obj) => {
            console.log(info, obj);
            if (info === "publish_started") {
              isPublishing = true;
              publishToggle.textContent = "Stop Publishing";
              publishToggle.classList.add("active-red");

              if (!isWebcamMode) {
                setTimeout(() => {
                  videoBg.play().catch((e) => console.log(e));
                }, 500);
                startSyncHeartbeat();
              }

              updateUI(); // Check visibility of tools
            }
            if (info === "publish_finished") {
              isPublishing = false;
              publishToggle.textContent = "Start Publish";
              publishToggle.classList.remove("active-red");
              stopSyncHeartbeat();
              videoBg.pause();

              updateUI(); // Check visibility of tools
            }
            if (info === "data_received") {
              try {
                const data = JSON.parse(obj.data);
                if (data.action === "wishlist_add") addLogItem(data.index);
                else if (data.action === "wishlist_remove")
                  removeLogItem(data.index);
              } catch (e) {}
            }
          },
          callbackError: (error, message) => {
            isPublishing = false;
            publishToggle.textContent = "Start Publish";
            publishToggle.classList.remove("active-red");
            stopSyncHeartbeat();
            videoBg.pause();
            updateUI();
          },
        });
      }

      function startSyncHeartbeat() {
        if (syncInterval) clearInterval(syncInterval);
        syncInterval = setInterval(() => {
          if (isPublishing && !isWebcamMode) {
            const action = isBgPlaying ? "play" : "pause";
            sendSyncData(action);
          }
        }, 2000);
      }

      function stopSyncHeartbeat() {
        if (syncInterval) {
          clearInterval(syncInterval);
          syncInterval = null;
        }
      }

      function sendSyncData(action, idx) {
        if (isPublishing && webRTCAdaptor) {
          try {
            const payload = JSON.stringify({ action: action, index: idx });
            webRTCAdaptor.sendData(streamId, payload);
          } catch (e) {
            console.error(e);
          }
        }
      }

      modeToggle.addEventListener("click", () => {
        isWebcamMode = !isWebcamMode;

        if (isWebcamMode) {
          // Pause BG when entering Webcam Mode
          videoBg.pause();
          isBgPlaying = false;
          stopSyncHeartbeat();
          // Force first product selection
          setManualProduct(0);
        } else {
          // Resume BG if publishing when returning to Video Mode
          if (isPublishing) {
            videoBg.play();
            startSyncHeartbeat();
          }
        }
        updateUI();
      });

      videoBg.addEventListener("play", () => {
        isBgPlaying = true;
        bgToggle.textContent = "Stop Background";
        bgToggle.classList.remove("active-green");
        bgToggle.classList.add("active-red");
        if (!isWebcamMode) sendSyncData("play");
      });

      videoBg.addEventListener("pause", () => {
        isBgPlaying = false;
        bgToggle.textContent = "Play Background";
        bgToggle.classList.remove("active-red");
        bgToggle.classList.add("active-green");
        if (!isWebcamMode) sendSyncData("pause");
      });

      publishToggle.addEventListener("click", () => {
        if (!webRTCAdaptor) return;
        if (isPublishing) webRTCAdaptor.stop(streamId);
        else webRTCAdaptor.publish(streamId);
      });

      bgToggle.addEventListener("click", () => {
        if (isBgPlaying) videoBg.pause();
        else videoBg.play();
      });

      resizeCanvas();
      initWebRTC();
      draw();
    </script>
  </body>
</html>
