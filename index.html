<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Canvas Stream - Presenter</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: sans-serif;
        background: #000;
      }
      video {
        position: absolute;
        width: 1px;
        height: 1px;
        opacity: 0;
        pointer-events: none;
      }
      canvas {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 0;
      }
      .controls {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 1;
        background: rgba(15, 15, 15, 0.75);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        padding: 14px 18px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .controls .btn-row {
        display: flex;
        gap: 6px;
      }
      .controls button {
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
        border: 1px solid rgba(255, 255, 255, 0.15);
        padding: 8px 14px;
        border-radius: 8px;
        font-size: 13px;
        cursor: pointer;
        transition:
          background 0.2s,
          border-color 0.2s;
      }
      .controls button:hover {
        background: rgba(255, 255, 255, 0.2);
        border-color: rgba(255, 255, 255, 0.3);
      }
      .controls button:active {
        background: rgba(255, 255, 255, 0.28);
      }
      .controls button.active-red {
        background: rgba(220, 38, 38, 0.8);
        border-color: rgba(220, 38, 38, 0.9);
      }
      .controls button.active-red:hover {
        background: rgba(220, 38, 38, 0.95);
      }
      .controls button.active-green {
        background: rgba(34, 160, 70, 0.8);
        border-color: rgba(34, 160, 70, 0.9);
      }
      .controls button.active-green:hover {
        background: rgba(34, 160, 70, 0.95);
      }
      .controls a {
        display: inline-block;
        color: #8ab4f8;
        font-size: 13px;
        text-decoration: none;
        transition: color 0.2s;
      }
      .controls a:hover {
        color: #aecbfa;
        text-decoration: underline;
      }
    </style>
  </head>
  <body>
    <video id="videoBg" src="./background.mp4" muted loop playsinline></video>
    <video id="webcam" autoplay muted playsinline></video>
    <canvas id="canvas"></canvas>

    <div class="controls">
      <div class="btn-row">
        <button id="bgToggle" class="active-green">Play Background</button>
      </div>
      <div class="btn-row">
        <button id="publishToggle">Start Publish</button>
      </div>
      <a href="./player.html" target="_blank">Open Player</a>
    </div>

    <script type="module">
      import { WebRTCAdaptor } from "https://cdn.skypack.dev/@antmedia/webrtc_adaptor@SNAPSHOT";

      const videoBg = document.getElementById("videoBg");
      const webcam = document.getElementById("webcam");
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const publishToggle = document.getElementById("publishToggle");
      const bgToggle = document.getElementById("bgToggle");

      var streamId = "streamCanvas";
      var webRTCAdaptor;
      var isPublishing = false;
      var isBgPlaying = false;

      const BOTTOM_MARGIN = 50;

      function resizeCanvas() {
        const targetW = videoBg.videoWidth || window.innerWidth;
        const targetH = videoBg.videoHeight || window.innerHeight;

        if (targetW && targetH) {
          canvas.width = targetW;
          canvas.height = targetH;
        }

        if (!canvas.width || !canvas.height) return;

        var ratio = canvas.width / canvas.height;
        var winW = window.innerWidth;
        var winH = window.innerHeight;
        var winRatio = winW / winH;
        if (winRatio > ratio) {
          canvas.style.height = winH + "px";
          canvas.style.width = Math.round(winH * ratio) + "px";
        } else {
          canvas.style.width = winW + "px";
          canvas.style.height = Math.round(winW / ratio) + "px";
        }
      }

      window.addEventListener("resize", resizeCanvas);

      navigator.mediaDevices
        .getUserMedia({
          video: { width: 640, height: 480 },
        })
        .then((stream) => {
          webcam.srcObject = stream;
        })
        .catch((err) => console.error(err));

      function draw() {
        ctx.fillStyle = "#000000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        if (videoBg.readyState >= 2) {
          ctx.drawImage(videoBg, 0, 0, canvas.width, canvas.height);
        }

        const camWidth = 550;
        const camHeight = 400;
        if (webcam.readyState >= 2) {
          ctx.drawImage(
            webcam,
            canvas.width - camWidth - 10,
            10,
            camWidth,
            camHeight,
          );
        }

        requestAnimationFrame(draw);
      }

      videoBg.addEventListener("loadedmetadata", () => {
        resizeCanvas();
        if (!webRTCAdaptor) initWebRTC();
      });

      function initWebRTC() {
        var localCanvasStream = canvas.captureStream(25);

        webRTCAdaptor = new WebRTCAdaptor({
          websocket_url: "wss://test.antmedia.io:5443/WebRTCAppEE/websocket",
          localStream: localCanvasStream,
          callback: (info, obj) => {
            console.log(info, obj);
            if (info === "publish_started") {
              isPublishing = true;
              publishToggle.textContent = "Stop Publishing";
              publishToggle.classList.add("active-red");

              if (isBgPlaying) {
                sendSyncData("play");
              } else {
                sendSyncData("pause");
              }
            }
            if (info === "publish_finished") {
              isPublishing = false;
              publishToggle.textContent = "Start Publish";
              publishToggle.classList.remove("active-red");
            }
          },
          callbackError: (error, message) => {
            console.error(error, message);
            isPublishing = false;
            publishToggle.textContent = "Start Publish";
            publishToggle.classList.remove("active-red");
          },
        });
      }

      function sendSyncData(action) {
        if (isPublishing && webRTCAdaptor) {
          try {
            const payload = JSON.stringify({ action: action });
            webRTCAdaptor.sendData(streamId, payload);
          } catch (e) {
            console.error(e);
          }
        }
      }

      videoBg.addEventListener("play", () => {
        isBgPlaying = true;
        bgToggle.textContent = "Stop Background";
        bgToggle.classList.remove("active-green");
        bgToggle.classList.add("active-red");
        sendSyncData("play");
      });

      videoBg.addEventListener("pause", () => {
        isBgPlaying = false;
        bgToggle.textContent = "Play Background";
        bgToggle.classList.remove("active-red");
        bgToggle.classList.add("active-green");
        sendSyncData("pause");
      });

      publishToggle.addEventListener("click", () => {
        if (!webRTCAdaptor) return;
        if (isPublishing) {
          webRTCAdaptor.stop(streamId);
        } else {
          webRTCAdaptor.publish(streamId);
        }
      });

      bgToggle.addEventListener("click", () => {
        if (isBgPlaying) {
          videoBg.pause();
        } else {
          videoBg.play();
        }
      });

      resizeCanvas();
      initWebRTC();
      draw();
    </script>
  </body>
</html>
